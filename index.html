<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Block Blast Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #4c1d95 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border-radius: 30px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
      gap: 20px;
    }

    h1 {
      font-size: 2.5rem;
      color: white;
      font-weight: bold;
    }

    .score-panel {
      text-align: right;
    }

    .score {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffd700;
      margin-bottom: 5px;
    }

    .high-score {
      font-size: 1.1rem;
      color: #90ee90;
      margin-bottom: 10px;
    }

    .reset-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.3s;
    }

    .reset-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .game-over {
      background: #ef4444;
      color: white;
      padding: 15px 30px;
      border-radius: 15px;
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
    }

    .grid-container {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(8, 48px);
      gap: 4px;
    }

    .cell {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
      position: relative;
      overflow: hidden;
    }

    .cell.placing {
      animation: placeCell 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes placeCell {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      60% { transform: scale(1.15) rotate(10deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    .cell.clearing {
      animation: clearCell 0.5s ease-out forwards;
    }

    @keyframes clearCell {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; filter: brightness(1.5); }
      100% { transform: scale(0); opacity: 0; }
    }

    .cell.line-highlight {
      animation: lineHighlight 0.3s ease-in-out;
    }

    @keyframes lineHighlight {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.8); box-shadow: 0 0 20px currentColor; }
    }

    .pieces-container {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .piece {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      cursor: grab;
      transition: all 0.3s;
      touch-action: none;
    }

    .piece:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .piece.dragging {
      opacity: 0.5;
    }

    .piece.placing-animation {
      animation: piecePlacing 0.3s ease-out;
    }

    @keyframes piecePlacing {
      0% { transform: scale(1); }
      50% { transform: scale(0.8); }
      100% { transform: scale(1); }
    }

    .piece-grid {
      display: grid;
      gap: 4px;
    }

    .piece-cell {
      width: 32px;
      height: 32px;
      border-radius: 6px;
    }

    .drag-preview {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.9;
      will-change: transform;
    }

    .drag-preview-inner {
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 10px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.5);
    }

    .drag-preview .piece-cell {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .combo-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      pointer-events: none;
      background: linear-gradient(135deg, #fbbf24, #f97316);
      color: white;
      padding: 20px 40px;
      border-radius: 20px;
      font-size: 2.5rem;
      font-weight: bold;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      animation: bounce 0.5s ease;
    }

    @keyframes bounce {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
    }

    .info {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
      margin-top: 20px;
    }

    .combo-text {
      color: #fbbf24;
      font-weight: bold;
      margin-top: 5px;
    }

    .durability-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .durability-number {
      color: white;
      font-weight: bold;
      font-size: 1.3rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Block Blast</h1>
      <div class="score-panel">
        <div class="score">–û—á–∫–∏: <span id="score">0</span></div>
        <div class="high-score">üèÜ –†–µ–∫–æ—Ä–¥: <span id="highScore">0</span></div>
        <button class="reset-btn" onclick="game.resetGame()">‚Üª –ó–∞–Ω–æ–≤–æ</button>
      </div>
    </div>

    <div id="gameOverMessage" class="game-over" style="display: none;">
      –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –ù–µ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤
    </div>

    <div class="grid-container">
      <div id="gameGrid" class="game-grid"></div>
    </div>

    <div id="piecesContainer" class="pieces-container"></div>

    <div class="info">
      –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ —Ñ–∏–≥—É—Ä—ã –Ω–∞ –ø–æ–ª–µ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
      <div id="comboText" class="combo-text" style="display: none;"></div>
    </div>
  </div>

  <div id="dragPreview" class="drag-preview" style="display: none;"></div>
  <div id="comboPopup" class="combo-popup" style="display: none;"></div>

  <script>
    const GRID_SIZE = 8;
    const PIECE_SHAPES = [
      [[true]], [[true, true]], [[true], [true]], [[true, true, true]], [[true], [true], [true]], 
      [[true, true], [true, true]], [[true, true, true], [true, false, false]], [[true, false], [true, true]], 
      [[true, true], [false, true]], [[false, true], [true, true]], [[true, true, true, true]], [[true], [true], [true], [true]],
      [[true, true, true], [false, true, false]], [[false, true, false], [true, true, true]], [[true, false], [true, false], [true, true]], 
      [[false, true], [false, true], [true, true]], [[true, true], [true, false], [true, false]], [[true, true], [false, true], [false, true]], 
      [[true, true, false], [false, true, true]], [[false, true, true], [true, true, false]]
    ];

    const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];

    if (typeof window.storage === 'undefined') {
      window.storage = {
        data: {},
        async get(key) { return this.data[key] ? { value: this.data[key] } : null; },
        async set(key, value) { this.data[key] = value; return { value }; }
      };
    }

    const game = {
      grid: [], score: 0, highScore: 0, pieces: [], selectedPiece: null, dragging: false,
      dragPosition: { x: 0, y: 0 }, previewCell: null, gameOver: false, combo: 0, piecesPlaced: 0,

      init() {
        this.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
        this.loadHighScore();
        this.pieces = this.generatePieces();
        this.renderGrid();
        this.renderPieces();
        this.setupEventListeners();
      },

      async loadHighScore() {
        try {
          const result = await window.storage.get('blockBlastHighScore');
          if (result) {
            this.highScore = parseInt(result.value);
            document.getElementById('highScore').textContent = this.highScore;
          }
        } catch (error) { console.log('No high score yet'); }
      },

      async updateHighScore(newScore) {
        if (newScore > this.highScore) {
          this.highScore = newScore;
          document.getElementById('highScore').textContent = this.highScore;
          try {
            await window.storage.set('blockBlastHighScore', newScore.toString());
          } catch (error) { console.error('Failed to save:', error); }
        }
      },

      generatePieces() {
        return Array(3).fill(null).map(() => ({
          shape: PIECE_SHAPES[Math.floor(Math.random() * PIECE_SHAPES.length)],
          color: COLORS[Math.floor(Math.random() * COLORS.length)],
          id: Math.random()
        }));
      },

      renderGrid() {
        const grid = document.getElementById('gameGrid');
        grid.innerHTML = '';
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = i;
            cell.dataset.col = j;
            this.updateCell(cell, i, j);
            grid.appendChild(cell);
          }
        }
      },

      updateCell(cell, i, j) {
        const data = this.grid[i][j];
        const color = data ? (typeof data === 'object' ? data.color : data) : null;
        const dur = data && typeof data === 'object' ? data.durability : 1;

        if (color) {
          cell.style.backgroundColor = color;
          cell.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
          if (dur > 1) {
            cell.innerHTML = `<div class="durability-overlay"><span class="durability-number">${dur}</span></div>`;
          } else {
            cell.innerHTML = '';
          }
        } else if (this.shouldShowPreview(i, j)) {
          cell.style.backgroundColor = 'rgba(255,255,255,0.3)';
          cell.style.boxShadow = 'none';
          cell.innerHTML = '';
        } else {
          cell.style.backgroundColor = 'rgba(255,255,255,0.05)';
          cell.style.boxShadow = 'none';
          cell.innerHTML = '';
        }
      },

      renderPieces() {
        const container = document.getElementById('piecesContainer');
        container.innerHTML = '';
        this.pieces.forEach(piece => {
          const div = document.createElement('div');
          div.className = 'piece';
          div.dataset.pieceId = piece.id;
          const grid = document.createElement('div');
          grid.className = 'piece-grid';
          grid.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 1fr)`;
          piece.shape.forEach(row => {
            row.forEach(cell => {
              const c = document.createElement('div');
              c.className = 'piece-cell';
              if (cell) {
                c.style.backgroundColor = piece.color;
                c.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
              } else {
                c.style.backgroundColor = 'transparent';
              }
              grid.appendChild(c);
            });
          });
          div.appendChild(grid);
          container.appendChild(div);
          div.addEventListener('mousedown', (e) => this.handleMouseDown(e, piece));
          div.addEventListener('touchstart', (e) => this.handleTouchStart(e, piece), { passive: false });
        });
      },

      setupEventListeners() {
        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
      },

      handleMouseDown(e, piece) {
        e.preventDefault();
        this.selectedPiece = piece;
        this.dragging = true;
        this.dragPosition = { x: e.clientX, y: e.clientY };
        this.showDragPreview();
        const el = document.querySelector(`[data-piece-id="${piece.id}"]`);
        if (el) el.classList.add('dragging');
      },

      handleTouchStart(e, piece) {
        e.preventDefault();
        this.selectedPiece = piece;
        this.dragging = true;
        const t = e.touches[0];
        this.dragPosition = { x: t.clientX, y: t.clientY };
        this.showDragPreview();
        const el = document.querySelector(`[data-piece-id="${piece.id}"]`);
        if (el) el.classList.add('dragging');
      },

      handleMouseMove(e) {
        if (this.dragging && this.selectedPiece) {
          e.preventDefault();
          const x = e.clientX, y = e.clientY;
          this.dragPosition = { x, y };
          const preview = document.getElementById('dragPreview');
          preview.style.left = x + 'px';
          preview.style.top = y + 'px';
          this.updatePreview(x, y);
        }
      },

      handleTouchMove(e) {
        if (this.dragging && this.selectedPiece) {
          e.preventDefault();
          const t = e.touches[0];
          const x = t.clientX, y = t.clientY;
          this.dragPosition = { x, y };
          const preview = document.getElementById('dragPreview');
          preview.style.left = x + 'px';
          preview.style.top = y + 'px';
          this.updatePreview(x, y);
        }
      },

      handleMouseUp(e) {
        if (this.dragging && this.selectedPiece && this.previewCell) {
          this.placePiece(this.selectedPiece, this.previewCell.row, this.previewCell.col);
        }
        this.endDrag();
      },

      handleTouchEnd(e) {
        if (this.dragging && this.selectedPiece && this.previewCell) {
          this.placePiece(this.selectedPiece, this.previewCell.row, this.previewCell.col);
        }
        this.endDrag();
      },

      endDrag() {
        this.dragging = false;
        this.selectedPiece = null;
        this.previewCell = null;
        document.getElementById('dragPreview').style.display = 'none';
        document.querySelectorAll('.piece').forEach(p => p.classList.remove('dragging'));
        this.renderGrid();
      },

      showDragPreview() {
        const preview = document.getElementById('dragPreview');
        preview.style.display = 'block';
        preview.style.left = this.dragPosition.x + 'px';
        preview.style.top = this.dragPosition.y + 'px';
        preview.style.transform = 'translate(-50%, -50%)';
        const grid = document.createElement('div');
        grid.className = 'piece-grid';
        grid.style.gridTemplateColumns = `repeat(${this.selectedPiece.shape[0].length}, 1fr)`;
        this.selectedPiece.shape.forEach(row => {
          row.forEach(cell => {
            const c = document.createElement('div');
            c.className = 'piece-cell';
            if (cell) {
              c.style.backgroundColor = this.selectedPiece.color;
              c.style.boxShadow = '0 4px 8px rgba(0,0,0,0.5)';
              c.style.border = '2px solid rgba(255,255,255,0.3)';
            } else {
              c.style.backgroundColor = 'transparent';
            }
            grid.appendChild(c);
          });
        });
        const inner = document.createElement('div');
        inner.className = 'drag-preview-inner';
        inner.appendChild(grid);
        preview.innerHTML = '';
        preview.appendChild(inner);
      },

      updatePreview(x, y) {
        const grid = document.getElementById('gameGrid');
        if (!grid) return;
        const rect = grid.getBoundingClientRect();
        const size = rect.width / GRID_SIZE;
        const col = Math.floor((x - rect.left) / size);
        const row = Math.floor((y - rect.top) / size);
        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          this.previewCell = this.canPlacePiece(this.selectedPiece, row, col) ? { row, col } : null;
        } else {
          this.previewCell = null;
        }
        this.renderGrid();
      },

      shouldShowPreview(row, col) {
        if (!this.previewCell || !this.selectedPiece) return false;
        for (let i = 0; i < this.selectedPiece.shape.length; i++) {
          for (let j = 0; j < this.selectedPiece.shape[i].length; j++) {
            if (this.selectedPiece.shape[i][j]) {
              if (this.previewCell.row + i === row && this.previewCell.col + j === col) return true;
            }
          }
        }
        return false;
      },

      canPlacePiece(piece, row, col) {
        for (let i = 0; i < piece.shape.length; i++) {
          for (let j = 0; j < piece.shape[i].length; j++) {
            if (piece.shape[i][j]) {
              const r = row + i, c = col + j;
              if (r >= GRID_SIZE || c >= GRID_SIZE || r < 0 || c < 0 || this.grid[r][c]) return false;
            }
          }
        }
        return true;
      },

      placePiece(piece, row, col) {
        const cells = [];
        for (let i = 0; i < piece.shape.length; i++) {
          for (let j = 0; j < piece.shape[i].length; j++) {
            if (piece.shape[i][j]) {
              this.grid[row + i][col + j] = { color: piece.color, durability: 1 };
              cells.push({ row: row + i, col: col + j });
            }
          }
        }
        const el = document.querySelector(`[data-piece-id="${piece.id}"]`);
        if (el) el.classList.add('placing-animation');
        this.pieces = this.pieces.filter(p => p.id !== piece.id);
        this.renderPieces();
        this.renderGrid();
        setTimeout(() => this.animatePlacedCells(cells), 50);
        setTimeout(() => this.checkAndClearLines(), 500);
      },

      animatePlacedCells(cells) {
        const grid = document.getElementById('gameGrid');
        const all = grid.querySelectorAll('.cell');
        cells.forEach((c, i) => {
          setTimeout(() => {
            const idx = c.row * GRID_SIZE + c.col;
            const cell = all[idx];
            if (cell) {
              cell.classList.add('placing');
              setTimeout(() => cell.classList.remove('placing'), 400);
            }
          }, i * 50);
        });
      },

      checkAndClearLines() {
        let lines = [];
        for (let i = 0; i < GRID_SIZE; i++) {
          if (this.grid[i].every(c => c !== false)) lines.push({ type: 'row', index: i });
        }
        for (let j = 0; j < GRID_SIZE; j++) {
          if (this.grid.every(r => r[j] !== false)) lines.push({ type: 'col', index: j });
        }
        if (lines.length > 0) {
          this.highlightLines(lines);
          setTimeout(() => this.animateClearLines(lines), 300);
          setTimeout(() => {
            lines.forEach(line => {
              if (line.type === 'row') {
                for (let j = 0; j < GRID_SIZE; j++) this.grid[line.index][j] = false;
              } else {
                for (let i = 0; i < GRID_SIZE; i++) this.grid[i][line.index] = false;
              }
            });
            this.combo++;
            this.showComboPopup();
            this.score += lines.length * 10 * (1 + (this.combo - 1) * 0.5);
            document.getElementById('score').textContent = Math.floor(this.score);
            this.updateHighScore(Math.floor(this.score));
            this.renderGrid();
            setTimeout(() => this.checkAndClearLines(), 100);
          }, 800);
        } else {
          this.combo = 0;
          this.updateComboText();
          if (this.pieces.length === 0) {
            this.pieces = this.generatePieces();
            this.renderPieces();
          }
          this.checkGameOver();
        }
      },

      highlightLines(lines) {
        const grid = document.getElementById('gameGrid');
        const cells = grid.querySelectorAll('.cell');
        lines.forEach(line => {
          if (line.type === 'row') {
            for (let j = 0; j < GRID_SIZE; j++) {
              cells[line.index * GRID_SIZE + j].classList.add('line-highlight');
            }
          } else {
            for (let i = 0; i < GRID_SIZE; i++) {
              cells[i * GRID_SIZE + line.index].classList.add('line-highlight');
            }
          }
        });
      },

      animateClearLines(lines) {
        const grid = document.getElementById('gameGrid');
        const cells = grid.querySelectorAll('.cell');
        lines.forEach(line => {
          if (line.type === 'row') {
            for (let j = 0; j < GRID_SIZE; j++) {
              const c = cells[line.index * GRID_SIZE + j];
              c.classList.remove('line-highlight');
              c.classList.add('clearing');
            }
          } else {
            for (let i = 0; i < GRID_SIZE; i++) {
              const c = cells[i * GRID_SIZE + line.index];
              c.classList.remove('line-highlight');
              c.classList.add('clearing');
            }
          }
        });
      },

      showComboPopup() {
        if (this.combo > 1) {
          const popup = document.getElementById('comboPopup');
          popup.textContent = `–ö–û–ú–ë–û x${this.combo}! üî•`;
          popup.style.display = 'block';
          setTimeout(() => popup.style.display = 'none', 1000);
        }
        this.updateComboText();
      },

      updateComboText() {
        const text = document.getElementById('comboText');
        if (this.combo > 0) {
          text.textContent = `–ö–æ–º–±–æ x${this.combo}!`;
          text.style.display = 'block';
        } else {
          text.style.display = 'none';
        }
      },

      checkGameOver() {
        const hasMove = this.pieces.some(piece => {
          for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
              if (this.canPlacePiece(piece, i, j)) return true;
            }
          }
          return false;
        });
        if (!hasMove) {
          this.gameOver = true;
          document.getElementById('gameOverMessage').style.display = 'block';
        }
      },

      resetGame() {
        this.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
        this.updateHighScore(this.score);
        this.score = 0;
        this.combo = 0;
        this.piecesPlaced = 0;
        this.pieces = this.generatePieces();
        this.selectedPiece = null;
        this.gameOver = false;
        this.previewCell = null;
        document.getElementById('score').textContent = this.score;
        document.getElementById('gameOverMessage').style.display = 'none';
        this.updateComboText();
        this.renderGrid();
        this.renderPieces();
      }
    };

    window.addEventListener('DOMContentLoaded', () => game.init());
  </script>
</body>
</html>